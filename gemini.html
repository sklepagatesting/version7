<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Gemini Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="color-scheme" content="light dark" />
  <style>
    /* Smooth scroll for message list */
    html { scroll-behavior: smooth; }
  </style>
</head>
<body class="bg-gray-50 dark:bg-neutral-900 text-gray-900 dark:text-gray-100 min-h-screen">
  <div class="max-w-3xl mx-auto p-4 sm:p-6">
    <!-- Header -->
    <header class="flex items-center justify-between gap-3 mb-4">
      <div class="flex items-center gap-3">
        <div class="size-10 rounded-2xl bg-gradient-to-br from-indigo-500 to-purple-500 shadow-md"></div>
        <div>
          <h1 class="text-xl font-semibold">Gemini Chat</h1>
          <p class="text-xs text-gray-500 dark:text-gray-400">Powered by @google/generative-ai</p>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <button id="clearBtn" class="text-sm px-3 py-2 rounded-xl bg-gray-200/70 hover:bg-gray-300 dark:bg-neutral-800 dark:hover:bg-neutral-700">Clear</button>
        <button id="newBtn" class="text-sm px-3 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700">New Chat</button>
      </div>
    </header>

    <!-- Messages -->
    <main id="messages" class="space-y-3 p-3 rounded-2xl bg-white dark:bg-neutral-800 shadow-sm min-h-[50vh]">
      <!-- Messages will appear here -->
      <div id="emptyState" class="text-center py-16 text-gray-500 dark:text-gray-400">
        <p class="text-sm">Ask me anythingâ€¦</p>
        <p class="text-xs mt-1">Your API key stays on the server. This UI calls <code class="bg-gray-100 dark:bg-neutral-700 px-1 rounded">/api/chat</code>.</p>
      </div>
    </main>

    <!-- Composer -->
    <form id="composer" class="mt-4 flex items-end gap-2">
      <textarea id="input" rows="1" placeholder="Type your message..." class="flex-1 resize-none rounded-2xl border border-gray-300 dark:border-neutral-700 bg-white dark:bg-neutral-800 px-4 py-3 outline-none focus:ring-2 focus:ring-indigo-500/60"></textarea>
      <button id="sendBtn" class="rounded-2xl px-4 py-3 bg-indigo-600 text-white hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">Send</button>
    </form>

    <!-- Footer note -->
    <p class="mt-3 text-[11px] text-gray-500 dark:text-gray-400">
      Tip: hold <kbd class="px-1 py-0.5 rounded border border-gray-300 dark:border-neutral-700">Shift</kbd> + <kbd class="px-1 py-0.5 rounded border border-gray-300 dark:border-neutral-700">Enter</kbd> for a new line. Message history is kept only in-page.
    </p>
  </div>

  <script>
    const messagesEl = document.getElementById('messages');
    const emptyStateEl = document.getElementById('emptyState');
    const inputEl = document.getElementById('input');
    const formEl = document.getElementById('composer');
    const sendBtn = document.getElementById('sendBtn');
    const clearBtn = document.getElementById('clearBtn');
    const newBtn = document.getElementById('newBtn');

    let abortController = null;

    function autoResize(el){
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 160) + 'px';
    }
    inputEl.addEventListener('input', () => autoResize(inputEl));

    function addBubble(role, content) {
      emptyStateEl?.remove();
      const wrapper = document.createElement('div');
      wrapper.className = `flex ${role === 'user' ? 'justify-end' : 'justify-start'}`;
      const bubble = document.createElement('div');
      bubble.className = `max-w-[85%] rounded-2xl px-4 py-3 shadow-sm whitespace-pre-wrap leading-relaxed ` +
        (role === 'user'
          ? 'bg-indigo-600 text-white rounded-br-md'
          : 'bg-gray-100 dark:bg-neutral-700 text-gray-900 dark:text-gray-100 rounded-bl-md');
      bubble.textContent = content;
      wrapper.appendChild(bubble);
      messagesEl.appendChild(wrapper);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return bubble;
    }

    function setLoading(loading){
      sendBtn.disabled = loading;
      inputEl.disabled = loading;
    }

    async function sendMessage(text){
      if(!text.trim()) return;
      setLoading(true);

      addBubble('user', text);
      inputEl.value = '';
      autoResize(inputEl);

      const assistantBubble = addBubble('assistant', '');

      // Stream from backend using fetch + ReadableStream
      abortController = new AbortController();
      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: text }),
          signal: abortController.signal
        });

        if(!res.ok){
          const errText = await res.text();
          assistantBubble.textContent = `Error ${res.status}: ${errText || res.statusText}`;
          return;
        }

        if(!res.body || !res.body.getReader){
          assistantBubble.textContent = await res.text();
          return;
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        while(true){
          const { value, done } = await reader.read();
          if(done) break;
          assistantBubble.textContent += decoder.decode(value, { stream: true });
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
      } catch(err){
        if(err.name !== 'AbortError'){
          assistantBubble.textContent = 'Request failed: ' + (err?.message || err);
        }
      } finally {
        setLoading(false);
        abortController = null;
      }
    }

    formEl.addEventListener('submit', (e) => {
      e.preventDefault();
      sendMessage(inputEl.value);
    });

    inputEl.addEventListener('keydown', (e) => {
      if(e.key === 'Enter' && !e.shiftKey){
        e.preventDefault();
        sendMessage(inputEl.value);
      }
    });

    clearBtn.addEventListener('click', () => {
      messagesEl.innerHTML = '';
      messagesEl.appendChild(emptyStateEl);
      inputEl.focus();
    });

    newBtn.addEventListener('click', () => {
      if(abortController){ abortController.abort(); }
      inputEl.value = '';
      autoResize(inputEl);
      messagesEl.innerHTML = '';
      messagesEl.appendChild(emptyStateEl);
      inputEl.focus();
    });
  </script>
</body>
</html>
